\chapter{Related Work}
\label{ch:Related-Work}

Many empirical studies have established code rationale as a highly sought after category of information lacking effective support for answering them. \cite{latoza_maintaining_2006, latoza_hard-answer_2010, ko_information_2007}
Rationale questions ask why code was implemented a certain way, why alternative implementations were not chosen, and what the hidden criteria might have been behind motivating design choices about code. \cite{latoza_hard-answer_2010}
From a survey of software developers, LaToza \etal \cite{latoza_maintaining_2006} found 66\% of respondents found understanding the intent behind a piece of code to be a serious problem, 
while 82\% report that it takes a lot of effort to understand ``why the code is implemented the way it is.''
Further, 51\% agree understanding the history of a piece of a code to be a serious problem. \cite{latoza_maintaining_2006}
In support of LaToza \etal's findings, Ko \etal's observational study of 17 software developers found it was rarely enough for developers to understand the cause of a program behaviour as developers also  sought after the historical reason for a program's current implementation. \cite{ko_information_2007}

Two particular sources of information that can be helpful for answering these code rationale questions is a software project's revision history and the issues from a project's issue tracking system. 
In the absence of knowledgeable colleagues, several studies observe and show consensus on developers seeking answers to code rationale questions through code change histories and bug reports. \cite{ko_information_2007, codoban_software_2015, robillard_turnover-induced_2021}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Existing Support for Revision History Exploration}

Through interviews and surveys, Codoban \etal \cite{codoban_software_2015} found existing history exploration tools to be limited by being only temporal.
Developers frequently use revision history for recovering rationale behind code and for understanding the evolution of a project, which a temporal view alone does not effectively support. \cite{codoban_software_2015} 
However, Codaban \etal observe current tools related to \entity{vcs} assume all history is equally important with a flat, non-hierarchical structure and only provide a temporal view of commited changes. \cite{codoban_software_2015}

Existing \entity{git} commands as tools for exploring revision history like ``blame'' \cite{gitblame} annotates each line in a file with information about the revision and the author that last modified a particular line.
If the revision that last modified a particular line was trivial such as deleting whitespace, then the developer would need to go through several iterations of running ``blame.''
To further find out about what was changed in the line, a developer would also have to use \entity{git} ``diff'' \cite{gitdiff} for showing the changes between two revisions or two versions of a file.
However, Codoban \etal's participants reported diffs were difficult to read due to the challenge of gaining any insight or intent of the change from a diff and needing to go through numerous diffs to understand a change. \cite{codoban_software_2015}

Graphical user interfaces (\entity{gui}) for \entity{git} like GitExtensions \cite{gitextensions} and Sourcetree \cite{sourcetree} streamline a view of revisions alongside diffs, saving the user from manually executing calls of \entity{git} ``blame'' and ``diff.'' 
Native \entity{git} integrations and third-party plugins for popular code editors have made the use of these \entity{git} features more convenient. 
For example, IntelliJ IDEA \cite{intellij} has a view for displaying the \entity{git} history of a project, similar to calling \entity{git} ``log.''
IntelliJ also has a view specifically for showing the commit history for a single file or directory. \cite{intellij-showhistory}
Third-party plugins such as GitToolBox for IntelliJ and GitLens for Visual Studio can also integrate information from \entity{git} ``blame'' by directly inlining a preview of the commit message and the author of the revision that last modified the line in a file.

While \entity{gui}s make it more convenient to inspect revisions one at a time and refer or jump to different revisions at different points in time, they do not address the concern of having to go through several diffs, many which can be irrelevant to a code snippet of interest, to find a meaningful explanation for the change.
Moreover, plugins that make the information retrieved from \entity{git} commands more accessible still only cover the temporal view of software history.
A developer would still need to go through several commits and diffs and meanwhile, several of the encountered commits could be trivial changes regarding the section of code or even the file they are interested in.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Improving Revision History and Exploration}

There have been many approaches to improving a developer's experience when exploring revision history in a software project. While these approaches do not focus on supporting code rationale questions, they do address the concern of improving the revision history for code changes in a software project.

Kawrykow and Robillard \cite{kawrykow_non-essential_2011} propose a technique for detecting non-essential changes in software history and therefore an approach to finding more meaningful representations of software changes.
Kawrykow and Robillard define ``non-essential'' changes as changes which are cosmetic in nature, generally behaviour-preserving, and unlikely to yield further insight into the roles of or relationships between the program entities they modify. \cite{kawrykow_non-essential_2011}
The approach in this thesis explores the use of heuristics for a similar purpose in reducing the number of trivial commits a developer must go through in a file's revision history when searching for code rationale information on why the code in a file looks the way it does.

Bradley and Murphy \cite{bradley_supporting_2011} investigate two user interfaces, Deep Intellisense and Rationalizer, for supporting software history exploration.
In their work, Bradley and Murphy introduce a model for expressing how software repository information is interconnected and use the model for comparing the effectiveness of two different presentation styles.
In their Rationalizer interface, they directly integrated historical information into the background of the source code editor for addressing the \emph{when}, \emph{who}, and \emph{why} for each line of code in a file and provided hyperlinks to relevant Bugzilla reports. \cite{bradley_supporting_2011}
This thesis is similar in that it also investigates and evaluates an approach to make exploring relevant commits in a file's revision history easier, while also making it more convenient to access a source of code rationale information for each commit.

For reducing the volume of commits a developer must explore, Chronos \cite{servant_history_2012} uses history slicing, a technique for identifying the minimal number of code modifications across any number of revisions for any segment of code, and offers a visualization of the evolution of any piece of code in a software project's code base.
For reasoning about the evolution of source code, CodeShovel \cite{grund_codeshovel_2021} uses revision history to construct method-level histories where the revisions affecting a method have been categorized into change categories.
While both tools make analyzing the history behind scoped code segments more efficient, the approach proposed in this thesis slightly differs as it makes the history for the code in a given file more efficient to explore for understanding the evolution for a specific file, rather than a method or a segment of code.
The approach this thesis investigates also differs in that it aims to support efficient reasoning about the evolution of source code through indicating more meaningful revisions and making sources of code rationale information more visible within the source code editor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Incorporating Issue Tracking Systems}

To supplement the code change information from software revision histories, previous work has also incorporated the use of peripheral project artifacts as richer sources of code rationale information. A common source of code rationale information is in a project's issue tracking system as issues can contain useful discussion such as the hypothesized causes of bugs, approaches to fixing the bugs, and the motivation behind a feature implementation. 
Issue tracking systems such as Jira also support extensive organization for issues, which can designate Jira issues belonging to different levels of abstraction.
For example, an issue on Jira can be categorized as a bug, task, sub-task of a larger task, story, or epic. \cite{jira-issue-types}
Jira issues can also be linked to each other by relationships such as ``caused by'' or ``relates to.''

Rastkar and Murphy \cite{rastkar_why_2013} applied multi-document summarization techniques on Jira issues at different levels of abstraction to generate summaries providing motivational information behind a code change.
Also recognizing Jira as a source of code rationale information, ARENA \cite{moreno_arena_2017} seeks to answer the \emph{what} and \emph{why} of code change between release notes by using the commits in a project's versioning system and the issues from the project's Jira instance to automatically generate release notes. 
ARENA summarizes the code changes between releases to answer \emph{what} changed in a newer release and uses the information from Jira to explain \emph{why}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Ultimately, previous work has focused on improving software history exploration by making revision history as a primary source of code change information easier to explore and visualize.
Other work not only uses revision history, but also incorporates a project's issue tracking system as a source of code rationale information. 
This thesis explores the development of an approach for making the exploration of the revision history for a given file more efficient, while also making access to the Jira issue information relevant to each commit in a file's revision history more convenient as the information is integrated in the source code editor.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\endinput

Any text after an \endinput is ignored.
You could put scraps here or things in progress.