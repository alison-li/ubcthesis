\chapter{Discussion}
\label{ch:Discussion}

% What questions would people ask about the work after reading up to this point?

In this chapter, we discuss the implications and limitations of our findings 
and suggestions for further investigation to expand on our work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Project Selection}

A limitation in our approach and findings is our use of a single open-source repository, Apache Kafka.
We used the commit histories of two files from Apache Kafka to develop the heuristics for defining a commit that contains trivial changes.
However, the generalizability of our results becomes limited to these files for Apache Kafka.
Our approach to commit highlighting described in \autoref{sec:Heuristics}
involves prioritizing pattern matching for categories of trivial changes in diffs.
Our current implementation requires a commit's diff to have at least 1 uncategorized change
for the commit to be highlighted in the commit history.
Else, the commit is faded out from the history if it only contains trivial changes according to the regular expression patterns
we developed for detecting trivial changes.

For the two files or Java classes we selected from Apache Kafka,
\class{Topology} and \class{StreamsBuilder},
our technique highlights less than half of both commit histories (41\% and 42\% respectively),
or in other words, it reduces the search space of commits to look at for a developer 
by more than half of the original commit histories.
However, if we were to apply this technique to another repository where the commit history is 
dominated by \emph{tangled changes} or the grouping of several changes into single commits, 
then this would impact the performance of our technique.
Tangled changes compromise the accuracy of analysis on a commit history \cite{herzig_tangled_2013}.
In our case, if every trivial change in a file was paired with a non-trivial change according to our heuristics,
then none of the commits in a file's commit history would be highlighted.
Consequently, one area of investigation for future work would be on how to
develop heuristics for commit histories involving tangled changes.

Additionally, a few participants described the utility of the commit highlighting
approach for helping them ignore ``irrelevant'' commits \participants{DFI}.
For developers, relevancy is in relation to a task or question.
Hence, another suggestion for future work would be to explore how
we can integrate task or context-sensitivity to our approach for distinguishing trivial or non-trivial
commits in a commit history.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Code Rationale in Information Retrieval}

Our approach assumes a project uses Jira for tracking and managing issues and has
a convention of explicitly referencing one Jira issue ID per commit.
In an effort to reduce the distance between commits and issues in an \entity{IDE},
our implementation in Intelligent History uses a regular expression pattern 
to extract a Jira issue ID from a commit message title.
However, we may wish to consider how we can adapt our technique for a wider range of
issue tracking system (\entity{ITS}) beyond Jira.

Another concern about our approach is our reliance on issues
as a source of code rationale information.
This arose as a concern among two participants, who mentioned working within projects
with commits that are not explicitly structured or associated with specific issues
from an \entity{ITS} \participants{AH}.
On how issues play a role in participant \participant{A}'s daily work, they said:

\begin{quote}
    I don’t actually typically look at issues. 
    The issues aren’t generally helpful because a lot of the people on my team don’t really use Jira. 
    It’s mostly my manager that uses Jira with the other managers. 
    [The people on my team] get assigned stuff but they don’t really interact with the issue at all.
\end{quote}

Not only does the performance of our approach depend on the specific
\entity{ITS} used and the practice of explicitly linking issues to commits,
but also the availability of code rationale information in the issues themselves.
As previously mentioned in \autoref{subsec:RQ3},
participant \participant{E} raised a point about the discussion in an issue as difficult to grokk.
Additionally, discussion about design, particularly in open-source projects,
is highly distributed across commits, issues, and pull requests \cite{brunet_design_2014}.
Participant \participant{J} mentioned:
``\textit{Since each issue corresponded to a pull request, we usually put [rationale] information in the pull request. 
The issue was just to explain the problem and the solution was in the pull request.}''
Thus, we find that a direction for future work is to explore approaches for aggregating and pre-processing
to improve the utility of an issue, and to present the aggregated or pre-processed information better in the \entity{IDE}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Diff and Issue Metadata}

In our implementation of Intelligent History,
we computed and integrated metadata metrics to summarize 
the content in commit diffs as \emph{diff metadata} and Jira issues as \emph{issue metadata} 
and displayed these metrics as additional information to the developer.
We exposed diff metadata to the developer to raise their confidence in how Intelligent History
determines commits to be highlighted or faded in a file's commit history.
We presented issue metadata to give the developer a summary of metrics about
an issue, which could help them more quickly determine if an issue was worth investigating further.

However, the results of our user study demonstrated that this metadata information largely went unused.
Two participants mentioned they were less motivated to use the (\feature{2}) \textit{Show Diff Metadata} feature
because accessing the information required a button click \participants{EF}.
A possible improvement could be to make this information available in a non-intrusive presentation,
such as by providing the metadata information upon a user hovering a commit.

For the issue metadata information embedded in (\feature{3}) \textit{Show Jira Metadata},
only two participants commented on using an issue's priority and other provided metrics added as part the presentation
of a Jira issue in the \entity{IDE} to determine whether the issue was worth further investigation \participants{IJ}.
Participant \participant{I} stated: 
``\textit{I liked how I was able to see the priority [of an issue] because if something has a higher priority, it usually involves heavier changes.}''
Similarly, participant \participant{C} commented:
``\textit{[The number of comments in an issue] might show you how active an issue is but the priority should be the main indicator.}''
This indicates that developers may use certain aspects about an issue as a signal 
for how meaningful a source code change might be and whether further reading into a change's associated issue
could provide insight on the motivation behind the change.

Rather than displaying the raw metadata information directly to the developer,
a suggestion we make for future work is to explore how this metadata information
can be used to measure the essentiality or non-essentiality of a commit.
This could help inform us of how to improve the presentation of important
commits, such as indicating the degree of importance for each commit 
instead of a binary decision on a commit as trivial or not trivial.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\endinput

Any text after an \endinput is ignored.
You could put scraps here or things in progress.