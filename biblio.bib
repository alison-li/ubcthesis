%% ACADEMIC
@inproceedings{rastkar_why_2013,
	address = {San Francisco, CA, USA},
	title = {Why did this code change?},
	isbn = {978-1-4673-3076-3 978-1-4673-3073-2},
	url = {http://ieeexplore.ieee.org/document/6606676/},
	doi = {10.1109/ICSE.2013.6606676},
	abstract = {When a developer works on code that is shared with other developers, she needs to know why the code has been changed in particular ways to avoid reintroducing bugs. A developer looking at a code change may have access to a short commit message or a link to a bug report which may provide detailed information about how the code changed but which often lacks information about what motivated the change. This motivational information can sometimes be found by piecing together information from a set of relevant project documents, but few developers have the time to ﬁnd and read the right documentation. We propose the use of multi-document summarization techniques to generate a concise natural language description of why code changed so that a developer can choose the right course of action.},
	language = {en},
	urldate = {2022-01-05},
	booktitle = {2013 35th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Rastkar, Sarah and Murphy, Gail C.},
	month = may,
	year = {2013},
	pages = {1193--1196},
}

@inproceedings{robillard_turnover-induced_2021,
	address = {Athens Greece},
	title = {Turnover-induced knowledge loss in practice},
	isbn = {978-1-4503-8562-6},
	url = {https://dl.acm.org/doi/10.1145/3468264.3473923},
	doi = {10.1145/3468264.3473923},
	abstract = {When contributors to a software project leave, the knowledge they hold may become lost, thus impacting code quality and team productivity. Although well-known strategies can be used to mitigate knowledge loss, these strategies have to be tailored to their target context to be effective. To help software development organizations mitigate turnover-induced knowledge loss, we sought to better understand the different contexts in which developers experience this knowledge loss, and the resulting implications. We conducted qualitative interviews with 27 professional developers and managers from three different companies that provide software products and services. Leveraging the experience of these practitioners, we contribute a framework for characterizing turnover-induced knowledge loss and descriptions of the implications of knowledge loss, synthesized into 20 observations. These observations about knowledge loss in practice are organized into four themes, validated by the participants, and discussed within the context of the research literature in software engineering.},
	language = {en},
	urldate = {2022-01-07},
	booktitle = {Proceedings of the 29th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Robillard, Martin P.},
	month = aug,
	year = {2021},
	pages = {1292--1302},
}

@inproceedings{ko_information_2007,
	address = {Minneapolis, MN, USA},
	title = {Information {Needs} in {Collocated} {Software} {Development} {Teams}},
	isbn = {978-0-7695-2828-1},
	url = {https://ieeexplore.ieee.org/document/4222596/},
	doi = {10.1109/ICSE.2007.45},
	language = {en},
	urldate = {2022-01-10},
	booktitle = {29th {International} {Conference} on {Software} {Engineering} ({ICSE}'07)},
	publisher = {IEEE},
	author = {Ko, Amy J. and DeLine, Robert and Venolia, Gina},
	month = may,
	year = {2007},
	pages = {344--353},
}

@article{moreno_arena_2017,
	title = {{ARENA}: {An} {Approach} for the {Automated} {Generation} of {Release} {Notes}},
	volume = {43},
	issn = {0098-5589, 1939-3520},
	shorttitle = {{ARENA}},
	url = {http://ieeexplore.ieee.org/document/7513412/},
	doi = {10.1109/TSE.2016.2591536},
	abstract = {Release notes document corrections, enhancements, and, in general, changes that were implemented in a new release of a software project. They are usually created manually and may include hundreds of different items, such as descriptions of new features, bug ﬁxes, structural changes, new or deprecated APIs, and changes to software licenses. Thus, producing them can be a time-consuming and daunting task. This paper describes ARENA (Automatic RElease Notes generAtor), an approach for the automatic generation of release notes. ARENA extracts changes from the source code, summarizes them, and integrates them with information from versioning systems and issue trackers. ARENA was designed based on the manual analysis of 990 existing release notes. In order to evaluate the quality of the release notes automatically generated by ARENA, we performed four empirical studies involving a total of 56 participants (48 professional developers and eight students). The obtained results indicate that the generated release notes are very good approximations of the ones manually produced by developers and often include important information that is missing in the manually created release notes.},
	language = {en},
	number = {2},
	urldate = {2022-01-13},
	journal = {IEEE Transactions on Software Engineering},
	author = {Moreno, Laura and Bavota, Gabriele and Penta, Massimiliano Di and Oliveto, Rocco and Marcus, Andrian and Canfora, Gerardo},
	month = feb,
	year = {2017},
	pages = {106--127},
}

@inproceedings{latoza_hard-answer_2010,
	address = {Reno, Nevada},
	title = {Hard-to-answer questions about code},
	isbn = {978-1-4503-0547-1},
	url = {http://portal.acm.org/citation.cfm?doid=1937117.1937125},
	doi = {10.1145/1937117.1937125},
	abstract = {To build new tools and programming languages that make it easier for professional software developers to create, debug, and understand code, it is helpful to better understand the questions that developers ask during coding activities. We surveyed professional software developers and asked them to list hard-to-answer questions that they had recently asked about code. 179 respondents reported 371 questions. We then clustered these questions into 21 categories and 94 distinct questions. The most frequently reported categories dealt with intent and rationale – what does this code do, what is it intended to do, and why was it done this way? Many questions described very specific situations – e.g., what does the code do when an error occurs, how to refactor without breaking callers, or the implications of a specific change on security. These questions revealed opportunities for both existing research tools to help developers and for developing new languages and tools that make answering these questions easier.},
	language = {en},
	urldate = {2022-01-14},
	booktitle = {Evaluation and {Usability} of {Programming} {Languages} and {Tools} on - {PLATEAU} '10},
	publisher = {ACM Press},
	author = {LaToza, Thomas D. and Myers, Brad A.},
	year = {2010},
	pages = {1--6},
}

@inproceedings{latoza_maintaining_2006,
	address = {Shanghai China},
	title = {Maintaining mental models: a study of developer work habits},
	isbn = {978-1-59593-375-1},
	shorttitle = {Maintaining mental models},
	url = {https://dl.acm.org/doi/10.1145/1134285.1134355},
	doi = {10.1145/1134285.1134355},
	abstract = {To understand developers’ typical tools, activities, and practices and their satisfaction with each, we conducted two surveys and eleven interviews. We found that many problems arose because developers were forced to invest great effort recovering implicit knowledge by exploring code and interrupting teammates and this knowledge was only saved in their memory. Contrary to expectations that email and IM prevent expensive task switches caused by face-to-face interruptions, we found that face-to-face communication enjoys many advantages. Contrary to expectations that documentation makes understanding design rationale easy, we found that current design documents are inadequate. Contrary to expectations that code duplication involves the copy and paste of code snippets, developers reported several types of duplication. We use data to characterize these and other problems and draw implications for the design of tools for their solution.},
	language = {en},
	urldate = {2022-01-14},
	booktitle = {Proceedings of the 28th international conference on {Software} engineering},
	publisher = {ACM},
	author = {LaToza, Thomas D. and Venolia, Gina and DeLine, Robert},
	month = may,
	year = {2006},
	pages = {492--501},
}

@inproceedings{bradley_supporting_2011,
	address = {Waikiki, Honolulu, HI, USA},
	title = {Supporting software history exploration},
	isbn = {978-1-4503-0574-7},
	url = {http://portal.acm.org/citation.cfm?doid=1985441.1985469},
	doi = {10.1145/1985441.1985469},
	abstract = {Software developers often confront questions such as “Why was the code implemented this way”? To answer such questions, developers make use of information in a software system’s bug and source repositories. In this paper, we consider two user interfaces for helping a developer explore information from such repositories. One user interface, from Holmes and Begel’s Deep Intellisense tool, exposes historical information across several integrated views, favouring exploration from a single code element to all of that element’s historical information. The second user interface, in a tool called Rationalizer that we introduce in this paper, integrates historical information into the source code editor, favouring exploration from a particular code line to its immediate history. We introduce a model to express how software repository information is connected and use this model to compare the two interfaces. Through a lab experiment, we found that our model can help predict which interface is helpful for a particular kind of historical question. We also found deﬁciencies in the interfaces that hindered users in the exploration of historical information. These results can help inform tool developers who are presenting historical information either directly from or mined from software repositories.},
	language = {en},
	urldate = {2022-01-14},
	booktitle = {Proceeding of the 8th working conference on {Mining} software repositories - {MSR} '11},
	publisher = {ACM Press},
	author = {Bradley, Alexander W.J. and Murphy, Gail C.},
	year = {2011},
	pages = {193},
}

@inproceedings{grund_codeshovel_2021,
	address = {Madrid, ES},
	title = {{CodeShovel}: {Constructing} {Method}-{Level} {Source} {Code} {Histories}},
	isbn = {978-1-66540-296-5},
	shorttitle = {{CodeShovel}},
	url = {https://ieeexplore.ieee.org/document/9402063/},
	doi = {10.1109/ICSE43902.2021.00135},
	abstract = {Source code histories are commonly used by developers and researchers to reason about how software evolves. Through a survey with 42 professional software developers, we learned that developers face signiﬁcant mismatches between the output provided by developers’ existing tools for examining source code histories and what they need to successfully complete their historical analysis tasks. To address these shortcomings, we propose CodeShovel, a tool for uncovering method histories that quickly produces complete and accurate change histories for 90\% methods (including 97\% of all method changes) outperforming leading tools from both research (e.g, FinerGit) and practice (e.g., IntelliJ / git log). CodeShovel helps developers to navigate the entire history of source code methods so they can better understand how the method evolved. A ﬁeld study on industrial code bases with 16 industrial developers conﬁrmed our empirical ﬁndings of CodeShovel’s correctness, low runtime overheads, and additionally showed that the approach can be useful for a wide range of industrial development tasks.},
	language = {en},
	urldate = {2022-01-17},
	booktitle = {2021 {IEEE}/{ACM} 43rd {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Grund, Felix and Chowdhury, Shaiful Alam and Bradley, Nick C. and Hall, Braxton and Holmes, Reid},
	month = may,
	year = {2021},
	pages = {1510--1522},
}

@inproceedings{codoban_software_2015,
	address = {Bremen, Germany},
	title = {Software history under the lens: {A} study on why and how developers examine it},
	isbn = {978-1-4673-7532-0},
	shorttitle = {Software history under the lens},
	url = {http://ieeexplore.ieee.org/document/7332446/},
	doi = {10.1109/ICSM.2015.7332446},
	abstract = {Despite software history being indispensable for developers, there is little empirical knowledge about how they examine software history. Without such knowledge, researchers and tool builders are in danger of making wrong assumptions and building inadequate tools.},
	language = {en},
	urldate = {2022-01-27},
	booktitle = {2015 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	publisher = {IEEE},
	author = {Codoban, Mihai and Ragavan, Sruti Srinivasa and Dig, Danny and Bailey, Brian},
	month = sep,
	year = {2015},
	pages = {1--10},
}

@inproceedings{servant_history_2012,
	address = {Cary, North Carolina},
	title = {History slicing: assisting code-evolution tasks},
	isbn = {978-1-4503-1614-9},
	shorttitle = {History slicing},
	url = {http://dl.acm.org/citation.cfm?doid=2393596.2393646},
	doi = {10.1145/2393596.2393646},
	abstract = {Many software-engineering tasks require developers to understand the history and evolution of source code. However, today’s software-development techniques and tools are not well suited for the easy and eﬃcient procurement of such information. In this paper, we present an approach called history slicing that can automatically identify a minimal number of code modiﬁcations, across any number of revisions, for any arbitrary segment of source code at ﬁne granularity. We also present our implementation of history slicing, Chronos, that includes a novel visualization of the entire evolution for the code of interest. We provide two experiments: one experiment automatically computes 16,000 history slices to determine the beneﬁt brought by various levels of automation, and another experiment that assesses the practical implications of history slicing for actual developers using the technique for actual software-maintenance tasks that involve code evolution. The experiments show that history slicing oﬀered drastic improvements over the conventional techniques in three ways: (1) the amount of information needed to be examined and traced by developers was reduced by up to three orders of magnitude; (2) the correctness of developers attempting to solve softwaremaintenance tasks was more than doubled; and (3) the time to completion of these software-maintenance tasks was almost halved.},
	language = {en},
	urldate = {2022-01-27},
	booktitle = {Proceedings of the {ACM} {SIGSOFT} 20th {International} {Symposium} on the {Foundations} of {Software} {Engineering} - {FSE} '12},
	publisher = {ACM Press},
	author = {Servant, Francisco and Jones, James A.},
	year = {2012},
	pages = {1},
}

@inproceedings{kawrykow_non-essential_2011,
	address = {Waikiki, Honolulu HI USA},
	title = {Non-essential changes in version histories},
	isbn = {978-1-4503-0445-0},
	url = {https://dl.acm.org/doi/10.1145/1985793.1985842},
	doi = {10.1145/1985793.1985842},
	abstract = {Numerous techniques involve mining change data captured in software archives to assist engineering efforts, for example to identify components that tend to evolve together. We observed that important changes to software artifacts are sometimes accompanied by numerous non-essential modiﬁcations, such as local variable refactorings, or textual differences induced as part of a rename refactoring. We developed a tool-supported technique for detecting nonessential code differences in the revision histories of software systems. We used our technique to investigate code changes in over 24 000 change sets gathered from the change histories of seven long-lived open-source systems. We found that up to 15.5\% of a system’s method updates were due solely to non-essential differences. We also report on numerous observations on the distribution of non-essential differences in change history and their potential impact on change-based analyses.},
	language = {en},
	urldate = {2022-01-27},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Kawrykow, David and Robillard, Martin P.},
	month = may,
	year = {2011},
	pages = {351--360},
}

@article{murphy_lightweight_1996,
	title = {Lightweight lexical source model extraction},
	volume = {5},
	issn = {1049-331X, 1557-7392},
	url = {https://dl.acm.org/doi/10.1145/234426.234441},
	doi = {10.1145/234426.234441},
	abstract = {Software engineers maintaining an existing software system often depend on the mechanized extraction of information from system artifacts. Some useful kinds of information—source models—are well known: call graphs, file dependences, etc. Predicting every kind of source model that a software engineer may need is impossible. We have developed a lightweight approach for generating flexible and tolerant source model extractors from lexical specifications. The approach is lightweight in that the specifications are relatively small and easy to write. It is flexible in that there are few constraints on the kinds of artifacts from which source models are extracted (e.g., we can extract from source code, structured data files, documentation, etc.). It is tolerant in that there are few constraints on the condition of the artifacts. For example, we can extract from source that cannot necessarily be compiled. Our approach extended the kinds of source models that can be easily produced from lexical information while avoiding the constraints and brittleness of most parser-based approaches. We have developed tools to support this approach and applied the tools to the extraction of a number of different source models (file dependences, event interactions, call graphs) from a variety of system artifacts (C, C++, CLOS, Eiffel. TCL, structured data). We discuss our approach and describe its application to extract source models not available using existing systems; for example, we compute the implicitly-invokes relation over Field tools. We compare and contrast our approach to the conventional lexical and syntactic approaches of generating source models.},
	language = {en},
	number = {3},
	urldate = {2022-02-12},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Murphy, Gail C. and Notkin, David},
	month = jul,
	year = {1996},
	pages = {262--292},
}

%% TOOLS
@online{vscode,
  title         = {Visual Studio Code - Code Editing. Redefined},
  year          = 2022,
  url           = {https://code.visualstudio.com/},
  note			= "Accessed March 4, 2022"
}

@online{eclipse,
  title         = {The Community for Open Innovation and Collaboration | The Eclipse Foundation},
  year          = "2022",
  url           = {https://www.eclipse.org/},
  note			= "Accessed March 4, 2022"
}

@online{intellij,
  title         = {IntelliJ IDEA: The Capable \& Ergonomic Java IDE by JetBrains},
  year          = "2022",
  url           = {https://www.jetbrains.com/idea/},
  note			= "Accessed March 4, 2022"
}

@online{intellij-showhistory,
  title         = {History tab | IntelliJ IDEA},
  year          = "2022",
  url           = {https://www.jetbrains.com/help/idea/version-control-tool-window-history-tab.html},
  note			= "Accessed April 4, 2022"
}

@online{gitblame,
  title         = {Git - git-blame Documentation},
  year          = "2022",
  url           = {https://git-scm.com/docs/git-blame},
  note			= "Accessed March 4, 2022"
}

@online{gitdiff,
  title         = {Git - git-diff Documentation},
  year          = "2022",
  url           = {https://git-scm.com/docs/git-diff},
  note			= "Accessed April 4, 2022"
}

@online{sourcetree,
  title         = {Sourcetree | Free Git GUI for Mac and Windows},
  year          = "2022",
  url           = {https://www.sourcetreeapp.com/},
  note			= "Accessed March 4, 2022"
}

@online{gitextensions,
  title         = {Git Extensions | Git Extensions is a standalone UI tool for managing Git repositories},
  year          = "2022",
  url           = {https://gitextensions.github.io/},
  note			= "Accessed March 4, 2022"
}

@online{jira,
  title         = {Jira | Issue \& Project Tracking Software | Atlassian},
  year          = "2022",
  url           = {https://www.atlassian.com/software/jira},
  note			= "Accessed March 4, 2022"
}

@online{jira-issue-types,
  title         = {What are issue types? | Atlassian Support},
  year          = "2022",
  url           = {https://support.atlassian.com/jira-cloud-administration/docs/what-are-issue-types/},
  note			= "Accessed April 4, 2022"
}