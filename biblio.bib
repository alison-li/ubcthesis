%% ACADEMIC
@inproceedings{bertram_social-nature_2010,
	author = {Bertram, Dane and Voida, Amy and Greenberg, Saul and Walker, Robert},
	title = {Communication, Collaboration, and Bugs: The Social Nature of Issue Tracking in Small, Collocated Teams},
	year = {2010},
	isbn = {9781605587950},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1718918.1718972},
	doi = {10.1145/1718918.1718972},
	abstract = {Issue tracking systems help organizations manage issue reporting, assignment, tracking, resolution, and archiving. Traditionally, it is the Software Engineering community that researches issue tracking systems, where software defects are reported and tracked as 'bug reports' within an archival database. Yet, as issue tracking is fundamentally a social process, it is important to understand the design and use of issue tracking systems from that perspective. Consequently, we conducted a qualitative study of issue tracking systems as used by small, collocated software development teams. We found that an issue tracker is not just a database for tracking bugs, features, and inquiries, but also a focal point for communication and coordination for many stakeholders within and beyond the software team. Customers, project managers, quality assurance personnel, and programmers all contribute to the shared knowledge and persistent communication that exists within the issue tracking system. These results were all the more striking because in spite of teams being collocated--which afforded frequent, face-to-face communication--the issue tracker was still used as a fundamental communication channel. We articulate various real-world practices surrounding issue trackers and offer design considerations for future systems.},
	booktitle = {Proceedings of the 2010 ACM Conference on Computer Supported Cooperative Work},
	pages = {291–300},
	numpages = {10},
	keywords = {software engineering, issue tracking, shared knowledge},
	location = {Savannah, Georgia, USA},
	series = {CSCW '10}
}

@inproceedings{baysal_issue-overload_2014,
	author = {Baysal, Olga and Holmes, Reid and Godfrey, Michael W.},
	title = {No Issue Left behind: Reducing Information Overload in Issue Tracking},
	year = {2014},
	isbn = {9781450330565},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2635868.2635887},
	doi = {10.1145/2635868.2635887},
	abstract = {Modern software development tools such as issue trackers are often complex and multi-purpose tools that provide access to an immense amount of raw information. Unfortunately, developers sometimes feel frustrated when they cannot easily obtain the particular information they need for a given task; furthermore, the constant influx of new data — the vast majority of which is irrelevant to their task at hand — may result in issues being "dropped on the floor". In this paper, we present a developer-centric approach to issue tracking that aims to reduce information overload and improve developers' situational awareness. Our approach is motivated by a grounded theory study of developer comments, which suggests that customized views of a project's repositories that are tailored to developer-specific tasks can help developers better track their progress and understand the surrounding technical context. From the qualitative study, we uncovered a model of the kinds of information elements that are essential for developers in completing their daily tasks, and from this model we built a tool organized around customized issue-tracking dashboards. Further quantitative and qualitative evaluation demonstrated that this dashboard-like approach to issue tracking can reduce the volume of irrelevant emails by over 99% and also improve support for specific issue-tracking tasks.},
	booktitle = {Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
	pages = {666–677},
	numpages = {12},
	keywords = {personalization, issue tracking, situational awareness, information needs, Developer dashboards},
	location = {Hong Kong, China},
	series = {FSE 2014}
}

@article{ruparelia_history-vcs_2010,
	author = {Ruparelia, Nayan B.},
	title = {The History of Version Control},
	year = {2010},
	issue_date = {January 2010},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {35},
	number = {1},
	issn = {0163-5948},
	url = {https://doi.org/10.1145/1668862.1668876},
	doi = {10.1145/1668862.1668876},
	journal = {SIGSOFT Softw. Eng. Notes},
	month = {jan},
	pages = {5–9},
	numpages = {5}
}

@inproceedings{li_what-help_2013,
  author={Li, Hongwei and Xing, Zhenchang and Peng, Xin and Zhao, Wenyun},
  booktitle={2013 20th Working Conference on Reverse Engineering (WCRE)}, 
  title={What help do developers seek, when and how?}, 
  year={2013},
  volume={},
  number={},
  pages={142-151},
  doi={10.1109/WCRE.2013.6671289}
}

@inproceedings{marques_task-relevant_2020,
  author={Marques, Arthur and Bradley, Nick C. and Murphy, Gail C.},
  booktitle={2020 IEEE International Conference on Software Maintenance and Evolution (ICSME)}, 
  title={Characterizing Task-Relevant Information in Natural Language Software Artifacts}, 
  year={2020},
  volume={},
  number={},
  pages={476-487},
  doi={10.1109/ICSME46990.2020.00052}
}

@article{cubranic_hipikat_2005,
  author={Cubranic, D. and Murphy, G.C. and Singer, J. and Booth, K.S.},
  journal={IEEE Transactions on Software Engineering}, 
  title={Hipikat: a project memory for software development}, 
  year={2005},
  volume={31},
  number={6},
  pages={446-465},
  doi={10.1109/TSE.2005.71}
}

@inproceedings{brunet_design_2014,
	author = {Brunet, Jo\~{a}o and Murphy, Gail C. and Terra, Ricardo and Figueiredo, Jorge and Serey, Dalton},
	title = {Do Developers Discuss Design?},
	year = {2014},
	isbn = {9781450328630},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2597073.2597115},
	doi = {10.1145/2597073.2597115},
	abstract = {Design is often raised in the literature as important to attaining various properties and characteristics in a software system. At least for open-source projects, it can be hard to find evidence of ongoing design work in the technical artifacts produced as part of the development. Although developers usually do not produce specific design documents, they do communicate about design in different ways. In this paper, we provide quantitative evidence that developers address design through discussions in commits, issues, and pull requests. To achieve this, we built a discussions' classifier and automatically labeled 102,122 discussions from 77 projects. Based on this data, we make four observations about the projects: i) on average, 25% of the discussions in a project are about design; ii) on average, 26% of developers contribute to at least one design discussion; iii) only 1% of the developers contribute to more than 15% of the discussions in a project; and iv) these few developers who contribute to a broad range of design discussions are also the top committers in a project.},
	booktitle = {Proceedings of the 11th Working Conference on Mining Software Repositories},
	pages = {340–343},
	numpages = {4},
	keywords = {Empirical Study, Machine Learning, Design Discussions},
	location = {Hyderabad, India},
	series = {MSR 2014}
}

@inproceedings{falleri_fine-grained_2014,
	author = {Falleri, Jean-R\'{e}my and Morandat, Flor\'{e}al and Blanc, Xavier and Martinez, Matias and Monperrus, Martin},
	title = {Fine-Grained and Accurate Source Code Differencing},
	year = {2014},
	isbn = {9781450330138},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2642937.2642982},
	doi = {10.1145/2642937.2642982},
	abstract = {At the heart of software evolution is a sequence of edit actions, called an edit script, made to a source code file. Since software systems are stored version by version, the edit script has to be computed from these versions, which is known as a complex task. Existing approaches usually compute edit scripts at the text granularity with only add line and delete line actions. However, inferring syntactic changes from such an edit script is hard. Since moving code is a frequent action performed when editing code, it should also be taken into account. In this paper, we tackle these issues by introducing an algorithm computing edit scripts at the abstract syntax tree granularity including move actions. Our objective is to compute edit scripts that are short and close to the original developer intent. Our algorithm is implemented in a freely-available and extensible tool that has been intensively validated.},
	booktitle = {Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering},
	pages = {313–324},
	numpages = {12},
	keywords = {ast, tree differencing, program comprehension, software evolution},
	location = {Vasteras, Sweden},
	series = {ASE '14}
}

@article{pawlik_RTED_2011,
	author = {Pawlik, Mateusz and Augsten, Nikolaus},
	title = {RTED: A Robust Algorithm for the Tree Edit Distance},
	year = {2011},
	issue_date = {December 2011},
	publisher = {VLDB Endowment},
	volume = {5},
	number = {4},
	issn = {2150-8097},
	url = {https://doi.org/10.14778/2095686.2095692},
	doi = {10.14778/2095686.2095692},
	abstract = {We consider the classical tree edit distance between ordered labeled trees, which is defined as the minimum-cost sequence of node edit operations that transform one tree into another. The state-of-the-art solutions for the tree edit distance are not satisfactory. The main competitors in the field either have optimal worst-case complexity, but the worst case happens frequently, or they are very efficient for some tree shapes, but degenerate for others. This leads to unpredictable and often infeasible runtimes. There is no obvious way to choose between the algorithms.In this paper we present RTED, a robust tree edit distance algorithm. The asymptotic complexity of RTED is smaller or equal to the complexity of the best competitors for any input instance, i.e., RTED is both efficient and worst-case optimal. We introduce the class of LRH (Left-Right-Heavy) algorithms, which includes RTED and the fastest tree edit distance algorithms presented in literature. We prove that RTED outperforms all previously proposed LRH algorithms in terms of runtime complexity. In our experiments on synthetic and real world data we empirically evaluate our solution and compare it to the state-of-the-art.},
	journal = {Proc. VLDB Endow.},
	month = {dec},
	pages = {334–345},
	numpages = {12}
}

@article{fluri_change_2007,
	author={Fluri, Beat and Wursch, Michael and PInzger, Martin and Gall, Harald},
	journal={IEEE Transactions on Software Engineering}, 
	title={Change Distilling:Tree Differencing for Fine-Grained Source Code Change Extraction}, 
	year={2007},
	volume={33},
	number={11},
	pages={725-743},
	doi={10.1109/TSE.2007.70731}
}

@inproceedings{ortu_jira_2015,
	author = {Ortu, Marco and Destefanis, Giuseppe and Adams, Bram and Murgia, Alessandro and Marchesi, Michele and Tonelli, Roberto},
	title = {The JIRA Repository Dataset: Understanding Social Aspects of Software Development},
	year = {2015},
	isbn = {9781450337151},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/2810146.2810147},
	doi = {10.1145/2810146.2810147},
	abstract = {Issue tracking systems store valuable data for testing hypotheses concerning maintenance, building statistical prediction models and recently investigating developers "affectiveness". In particular, the Jira Issue Tracking System is a proprietary tracking system that has gained a tremendous popularity in the last years and offers unique features like the project management system and the Jira agile kanban board. This paper presents a dataset extracted from the Jira ITS of four popular open source ecosystems (as well as the tools and infrastructure used for extraction) the Apache Software Foundation, Spring, JBoss and CodeHaus communities. Our dataset hosts more than 1K projects, containing more than 700K issue reports and more than 2 million issue comments. Using this data, we have been able to deeply study the communication process among developers, and how this aspect affects the development process. Furthermore, comments posted by developers contain not only technical information, but also valuable information about sentiments and emotions. Since sentiment analysis and human aspects in software engineering are gaining more and more importance in the last years, with this repository we would like to encourage further studies in this direction.},
	booktitle = {Proceedings of the 11th International Conference on Predictive Models and Data Analytics in Software Engineering},
	articleno = {1},
	numpages = {4},
	keywords = {Mining software repository, Issue Report, Affective Analysis},
	location = {Beijing, China},
	series = {PROMISE '15}
}

@inproceedings{hassan_road_2008,
	author={Hassan, Ahmed E.},
	booktitle={2008 Frontiers of Software Maintenance}, 
	title={The road ahead for Mining Software Repositories}, 
	year={2008},
	volume={},
	number={},
	pages={48-57},
	doi={10.1109/FOSM.2008.4659248}
}

@inproceedings{herzig_tangled_2013,
	author={Herzig, Kim and Zeller, Andreas},
	booktitle={2013 10th Working Conference on Mining Software Repositories (MSR)}, 
	title={The impact of tangled code changes}, 
	year={2013},
	volume={},
	number={},
	pages={121-130},
	doi={10.1109/MSR.2013.6624018}
}

@article{murphy-hill_refactor_2012,
	author={Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.},
	journal={IEEE Transactions on Software Engineering}, 
	title={How We Refactor, and How We Know It}, 
	year={2012},
	volume={38},
	number={1},
	pages={5-18},
	doi={10.1109/TSE.2011.41}
}

@book{shull_guide_2007,
	author = {Shull, Forrest and Singer, Janice and Sj\o{}berg, Dag I.K.},
	title = {Guide to Advanced Empirical Software Engineering},
	year = {2007},
	isbn = {184800043X},
	publisher = {Springer-Verlag},
	address = {Berlin, Heidelberg}
}

@inproceedings{dyer_boa_2013,
	author={Dyer, Robert and Nguyen, Hoan Anh and Rajan, Hridesh and Nguyen, Tien N.},
	booktitle={2013 35th International Conference on Software Engineering (ICSE)}, 
	title={Boa: A language and infrastructure for analyzing ultra-large-scale software 	repositories}, 
	year={2013},
	volume={},
	number={},
	pages={422-431},
	doi={10.1109/ICSE.2013.6606588}
}
  
@inproceedings{rastkar_why_2013,
	address = {San Francisco, CA, USA},
	title = {Why did this code change?},
	isbn = {978-1-4673-3076-3 978-1-4673-3073-2},
	url = {http://ieeexplore.ieee.org/document/6606676/},
	doi = {10.1109/ICSE.2013.6606676},
	abstract = {When a developer works on code that is shared with other developers, she needs to know why the code has been changed in particular ways to avoid reintroducing bugs. A developer looking at a code change may have access to a short commit message or a link to a bug report which may provide detailed information about how the code changed but which often lacks information about what motivated the change. This motivational information can sometimes be found by piecing together information from a set of relevant project documents, but few developers have the time to ﬁnd and read the right documentation. We propose the use of multi-document summarization techniques to generate a concise natural language description of why code changed so that a developer can choose the right course of action.},
	language = {en},
	urldate = {2022-01-05},
	booktitle = {2013 35th {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Rastkar, Sarah and Murphy, Gail C.},
	month = may,
	year = {2013},
	pages = {1193--1196},
}

@inproceedings{robillard_turnover-induced_2021,
	address = {Athens Greece},
	title = {Turnover-induced knowledge loss in practice},
	isbn = {978-1-4503-8562-6},
	url = {https://dl.acm.org/doi/10.1145/3468264.3473923},
	doi = {10.1145/3468264.3473923},
	abstract = {When contributors to a software project leave, the knowledge they hold may become lost, thus impacting code quality and team productivity. Although well-known strategies can be used to mitigate knowledge loss, these strategies have to be tailored to their target context to be effective. To help software development organizations mitigate turnover-induced knowledge loss, we sought to better understand the different contexts in which developers experience this knowledge loss, and the resulting implications. We conducted qualitative interviews with 27 professional developers and managers from three different companies that provide software products and services. Leveraging the experience of these practitioners, we contribute a framework for characterizing turnover-induced knowledge loss and descriptions of the implications of knowledge loss, synthesized into 20 observations. These observations about knowledge loss in practice are organized into four themes, validated by the participants, and discussed within the context of the research literature in software engineering.},
	language = {en},
	urldate = {2022-01-07},
	booktitle = {Proceedings of the 29th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {ACM},
	author = {Robillard, Martin P.},
	month = aug,
	year = {2021},
	pages = {1292--1302},
}

@inproceedings{ko_information_2007,
	address = {Minneapolis, MN, USA},
	title = {Information {Needs} in {Collocated} {Software} {Development} {Teams}},
	isbn = {978-0-7695-2828-1},
	url = {https://ieeexplore.ieee.org/document/4222596/},
	doi = {10.1109/ICSE.2007.45},
	language = {en},
	urldate = {2022-01-10},
	booktitle = {29th {International} {Conference} on {Software} {Engineering} ({ICSE}'07)},
	publisher = {IEEE},
	author = {Ko, Amy J. and DeLine, Robert and Venolia, Gina},
	month = may,
	year = {2007},
	pages = {344--353},
}

@article{moreno_arena_2017,
	title = {{ARENA}: {An} {Approach} for the {Automated} {Generation} of {Release} {Notes}},
	volume = {43},
	issn = {0098-5589, 1939-3520},
	shorttitle = {{ARENA}},
	url = {http://ieeexplore.ieee.org/document/7513412/},
	doi = {10.1109/TSE.2016.2591536},
	abstract = {Release notes document corrections, enhancements, and, in general, changes that were implemented in a new release of a software project. They are usually created manually and may include hundreds of different items, such as descriptions of new features, bug ﬁxes, structural changes, new or deprecated APIs, and changes to software licenses. Thus, producing them can be a time-consuming and daunting task. This paper describes ARENA (Automatic RElease Notes generAtor), an approach for the automatic generation of release notes. ARENA extracts changes from the source code, summarizes them, and integrates them with information from versioning systems and issue trackers. ARENA was designed based on the manual analysis of 990 existing release notes. In order to evaluate the quality of the release notes automatically generated by ARENA, we performed four empirical studies involving a total of 56 participants (48 professional developers and eight students). The obtained results indicate that the generated release notes are very good approximations of the ones manually produced by developers and often include important information that is missing in the manually created release notes.},
	language = {en},
	number = {2},
	urldate = {2022-01-13},
	journal = {IEEE Transactions on Software Engineering},
	author = {Moreno, Laura and Bavota, Gabriele and Penta, Massimiliano Di and Oliveto, Rocco and Marcus, Andrian and Canfora, Gerardo},
	month = feb,
	year = {2017},
	pages = {106--127},
}

@inproceedings{latoza_hard-answer_2010,
	address = {Reno, Nevada},
	title = {Hard-to-answer questions about code},
	isbn = {978-1-4503-0547-1},
	url = {http://portal.acm.org/citation.cfm?doid=1937117.1937125},
	doi = {10.1145/1937117.1937125},
	abstract = {To build new tools and programming languages that make it easier for professional software developers to create, debug, and understand code, it is helpful to better understand the questions that developers ask during coding activities. We surveyed professional software developers and asked them to list hard-to-answer questions that they had recently asked about code. 179 respondents reported 371 questions. We then clustered these questions into 21 categories and 94 distinct questions. The most frequently reported categories dealt with intent and rationale -- what does this code do, what is it intended to do, and why was it done this way? Many questions described very specific situations -- e.g., what does the code do when an error occurs, how to refactor without breaking callers, or the implications of a specific change on security. These questions revealed opportunities for both existing research tools to help developers and for developing new languages and tools that make answering these questions easier.},
	language = {en},
	urldate = {2022-01-14},
	booktitle = {Evaluation and {Usability} of {Programming} {Languages} and {Tools} on - {PLATEAU} '10},
	publisher = {ACM Press},
	author = {LaToza, Thomas D. and Myers, Brad A.},
	year = {2010},
	pages = {1--6},
}

@inproceedings{latoza_maintaining_2006,
	address = {Shanghai China},
	title = {Maintaining mental models: a study of developer work habits},
	isbn = {978-1-59593-375-1},
	shorttitle = {Maintaining mental models},
	url = {https://dl.acm.org/doi/10.1145/1134285.1134355},
	doi = {10.1145/1134285.1134355},
	abstract = {To understand developers’ typical tools, activities, and practices and their satisfaction with each, we conducted two surveys and eleven interviews. We found that many problems arose because developers were forced to invest great effort recovering implicit knowledge by exploring code and interrupting teammates and this knowledge was only saved in their memory. Contrary to expectations that email and IM prevent expensive task switches caused by face-to-face interruptions, we found that face-to-face communication enjoys many advantages. Contrary to expectations that documentation makes understanding design rationale easy, we found that current design documents are inadequate. Contrary to expectations that code duplication involves the copy and paste of code snippets, developers reported several types of duplication. We use data to characterize these and other problems and draw implications for the design of tools for their solution.},
	language = {en},
	urldate = {2022-01-14},
	booktitle = {Proceedings of the 28th international conference on {Software} engineering},
	publisher = {ACM},
	author = {LaToza, Thomas D. and Venolia, Gina and DeLine, Robert},
	month = may,
	year = {2006},
	pages = {492--501},
}

@inproceedings{bradley_supporting_2011,
	address = {Waikiki, Honolulu, HI, USA},
	title = {Supporting software history exploration},
	isbn = {978-1-4503-0574-7},
	url = {http://portal.acm.org/citation.cfm?doid=1985441.1985469},
	doi = {10.1145/1985441.1985469},
	abstract = {Software developers often confront questions such as “Why was the code implemented this way”? To answer such questions, developers make use of information in a software system’s bug and source repositories. In this paper, we consider two user interfaces for helping a developer explore information from such repositories. One user interface, from Holmes and Begel’s Deep Intellisense tool, exposes historical information across several integrated views, favouring exploration from a single code element to all of that element’s historical information. The second user interface, in a tool called Rationalizer that we introduce in this paper, integrates historical information into the source code editor, favouring exploration from a particular code line to its immediate history. We introduce a model to express how software repository information is connected and use this model to compare the two interfaces. Through a lab experiment, we found that our model can help predict which interface is helpful for a particular kind of historical question. We also found deﬁciencies in the interfaces that hindered users in the exploration of historical information. These results can help inform tool developers who are presenting historical information either directly from or mined from software repositories.},
	language = {en},
	urldate = {2022-01-14},
	booktitle = {Proceeding of the 8th working conference on {Mining} software repositories - {MSR} '11},
	publisher = {ACM Press},
	author = {Bradley, Alexander W.J. and Murphy, Gail C.},
	year = {2011},
	pages = {193},
}

@inproceedings{grund_codeshovel_2021,
	address = {Madrid, ES},
	title = {{CodeShovel}: {Constructing} {Method}-{Level} {Source} {Code} {Histories}},
	isbn = {978-1-66540-296-5},
	shorttitle = {{CodeShovel}},
	url = {https://ieeexplore.ieee.org/document/9402063/},
	doi = {10.1109/ICSE43902.2021.00135},
	abstract = {Source code histories are commonly used by developers and researchers to reason about how software evolves. Through a survey with 42 professional software developers, we learned that developers face signiﬁcant mismatches between the output provided by developers’ existing tools for examining source code histories and what they need to successfully complete their historical analysis tasks. To address these shortcomings, we propose CodeShovel, a tool for uncovering method histories that quickly produces complete and accurate change histories for 90\% methods (including 97\% of all method changes) outperforming leading tools from both research (e.g, FinerGit) and practice (e.g., IntelliJ / git log). CodeShovel helps developers to navigate the entire history of source code methods so they can better understand how the method evolved. A ﬁeld study on industrial code bases with 16 industrial developers conﬁrmed our empirical ﬁndings of CodeShovel’s correctness, low runtime overheads, and additionally showed that the approach can be useful for a wide range of industrial development tasks.},
	language = {en},
	urldate = {2022-01-17},
	booktitle = {2021 {IEEE}/{ACM} 43rd {International} {Conference} on {Software} {Engineering} ({ICSE})},
	publisher = {IEEE},
	author = {Grund, Felix and Chowdhury, Shaiful Alam and Bradley, Nick C. and Hall, Braxton and Holmes, Reid},
	month = may,
	year = {2021},
	pages = {1510--1522},
}

@inproceedings{codoban_software_2015,
	address = {Bremen, Germany},
	title = {Software history under the lens: {A} study on why and how developers examine it},
	isbn = {978-1-4673-7532-0},
	shorttitle = {Software history under the lens},
	url = {http://ieeexplore.ieee.org/document/7332446/},
	doi = {10.1109/ICSM.2015.7332446},
	abstract = {Despite software history being indispensable for developers, there is little empirical knowledge about how they examine software history. Without such knowledge, researchers and tool builders are in danger of making wrong assumptions and building inadequate tools.},
	language = {en},
	urldate = {2022-01-27},
	booktitle = {2015 {IEEE} {International} {Conference} on {Software} {Maintenance} and {Evolution} ({ICSME})},
	publisher = {IEEE},
	author = {Codoban, Mihai and Ragavan, Sruti Srinivasa and Dig, Danny and Bailey, Brian},
	month = sep,
	year = {2015},
	pages = {1--10},
}

@inproceedings{servant_history_2012,
	address = {Cary, North Carolina},
	title = {History slicing: assisting code-evolution tasks},
	isbn = {978-1-4503-1614-9},
	shorttitle = {History slicing},
	url = {http://dl.acm.org/citation.cfm?doid=2393596.2393646},
	doi = {10.1145/2393596.2393646},
	abstract = {Many software-engineering tasks require developers to understand the history and evolution of source code. However, today’s software-development techniques and tools are not well suited for the easy and eﬃcient procurement of such information. In this paper, we present an approach called history slicing that can automatically identify a minimal number of code modiﬁcations, across any number of revisions, for any arbitrary segment of source code at ﬁne granularity. We also present our implementation of history slicing, Chronos, that includes a novel visualization of the entire evolution for the code of interest. We provide two experiments: one experiment automatically computes 16,000 history slices to determine the beneﬁt brought by various levels of automation, and another experiment that assesses the practical implications of history slicing for actual developers using the technique for actual software-maintenance tasks that involve code evolution. The experiments show that history slicing oﬀered drastic improvements over the conventional techniques in three ways: (1) the amount of information needed to be examined and traced by developers was reduced by up to three orders of magnitude; (2) the correctness of developers attempting to solve softwaremaintenance tasks was more than doubled; and (3) the time to completion of these software-maintenance tasks was almost halved.},
	language = {en},
	urldate = {2022-01-27},
	booktitle = {Proceedings of the {ACM} {SIGSOFT} 20th {International} {Symposium} on the {Foundations} of {Software} {Engineering} - {FSE} '12},
	publisher = {ACM Press},
	author = {Servant, Francisco and Jones, James A.},
	year = {2012},
	pages = {1},
}

@inproceedings{kawrykow_non-essential_2011,
	address = {Waikiki, Honolulu HI USA},
	title = {Non-essential changes in version histories},
	isbn = {978-1-4503-0445-0},
	url = {https://dl.acm.org/doi/10.1145/1985793.1985842},
	doi = {10.1145/1985793.1985842},
	abstract = {Numerous techniques involve mining change data captured in software archives to assist engineering efforts, for example to identify components that tend to evolve together. We observed that important changes to software artifacts are sometimes accompanied by numerous non-essential modiﬁcations, such as local variable refactorings, or textual differences induced as part of a rename refactoring. We developed a tool-supported technique for detecting nonessential code differences in the revision histories of software systems. We used our technique to investigate code changes in over 24 000 change sets gathered from the change histories of seven long-lived open-source systems. We found that up to 15.5\% of a system’s method updates were due solely to non-essential differences. We also report on numerous observations on the distribution of non-essential differences in change history and their potential impact on change-based analyses.},
	language = {en},
	urldate = {2022-01-27},
	booktitle = {Proceedings of the 33rd {International} {Conference} on {Software} {Engineering}},
	publisher = {ACM},
	author = {Kawrykow, David and Robillard, Martin P.},
	month = may,
	year = {2011},
	pages = {351--360},
}

%% TOOLS
@online{vscode,
  title         = {Visual Studio Code - Code Editing. Redefined},
  year          = 2022,
  url           = {https://code.visualstudio.com/},
  note			= "Accessed March 4, 2022"
}

@online{eclipse,
  title         = {The Community for Open Innovation and Collaboration | The Eclipse Foundation},
  year          = "2022",
  url           = {https://www.eclipse.org/},
  note			= "Accessed March 4, 2022"
}

@online{intellij,
  title         = {IntelliJ IDEA: The Capable \& Ergonomic Java IDE by JetBrains},
  year          = "2022",
  url           = {https://www.jetbrains.com/idea/},
  note			= "Accessed March 4, 2022"
}

@online{intellij-showhistory,
  title         = {History tab | IntelliJ IDEA},
  year          = "2022",
  url           = {https://www.jetbrains.com/help/idea/version-control-tool-window-history-tab.html},
  note			= "Accessed April 4, 2022"
}

@online{gitblame,
  title         = {Git - git-blame Documentation},
  year          = "2022",
  url           = {https://git-scm.com/docs/git-blame},
  note			= "Accessed March 4, 2022"
}

@online{gitdiff,
  title         = {Git - git-diff Documentation},
  year          = "2022",
  url           = {https://git-scm.com/docs/git-diff},
  note			= "Accessed April 4, 2022"
}

@online{sourcetree,
  title         = {Sourcetree | Free Git GUI for Mac and Windows},
  year          = "2022",
  url           = {https://www.sourcetreeapp.com/},
  note			= "Accessed March 4, 2022"
}

@online{gitextensions,
  title         = {Git Extensions | Git Extensions is a standalone UI tool for managing Git repositories},
  year          = "2022",
  url           = {https://gitextensions.github.io/},
  note			= "Accessed March 4, 2022"
}

@online{jira,
  title         = {Jira | Issue \& Project Tracking Software | Atlassian},
  year          = "2022",
  url           = {https://www.atlassian.com/software/jira},
  note			= "Accessed March 4, 2022"
}

@online{jira-issue-types,
  title         = {What are issue types? | Atlassian Support},
  year          = "2022",
  url           = {https://support.atlassian.com/jira-cloud-administration/docs/what-are-issue-types/},
  note			= "Accessed April 4, 2022"
}

@online{gittoolbox,
  title         = {GitToolBox - IntelliJ IDEs Plugin | Marketplace},
  year          = "2022",
  url           = {https://plugins.jetbrains.com/plugin/7499-gittoolbox},
  note			= "Accessed April 5, 2022"
}

@online{gitlens,
  title         = {GitLens - Git supercharged},
  year          = "2022",
  url           = {https://gitlens.amod.io/},
  note			= "Accessed April 5, 2022"
}

@online{java-diff-utils,
  title         = {java-diff-utils},
  year          = "2022",
  url           = {https://java-diff-utils.github.io/java-diff-utils/},
  note			= "Accessed May 23, 2022"
}